import {
    APIError,
    Base64u,
    isInstanceOf,
    SessionError,
    SigningRequest,
} from '@proton/link'

import type { LinkTransport, LinkStorage, LinkChannelSession, LinkSession, Bytes } from '@proton/link'

import QRCode from 'qrcode'

import { fuel, compareVersion as fuelVersion } from './fuel'
import DialogWidget from './views/Dialog.svelte'
import { isFirefox, isBrave, isMobile, isChromeiOS, isFirefoxiOS, isAppleHandheld, isAndroid, isEdge, isOpera, isAndroidWebView, isChromeMobile } from './utils'

const AbortPrepare = Symbol()
const SkipFee = Symbol()
const SkipToManual = Symbol()

export interface BrowserTransportOptions {
    /** CSS class prefix, defaults to `proton-link` */
    classPrefix?: string
    /** Whether to display request success and error messages, defaults to true */
    requestStatus?: boolean
    /** Requesting account of the dapp (optional) */
    requestAccount?: string
    /** Wallet name e.g. proton, anchor, etc */
    walletType?: string
    /** Option to include back button in transport modal */
    backButton?: boolean
    /** Local storage prefix, defaults to `proton-link`. */
    storagePrefix?: string
    /**
     * Whether to use Greymass Fuel for low resource accounts, defaults to false.
     * Note that this service is not available on all networks.
     * Visit https://greymass.com/en/fuel for more information.
     */
    disableGreymassFuel?: boolean
    /**
     * The referring account to pass along to the Greymass Fuel API endpoint.
     * Specifying an account name will indicate to the API which account is eligible
     * to potentially receive a share of the fees generated by their application.
     */
    fuelReferrer?: string
    /**
     * Override of the supported resource provider chains.
     */
    supportedChains?: Record<string, string>
}

interface footNoteDownloadLinks {
    [key: string]: string
}

const footnoteLinks: footNoteDownloadLinks = {
    proton: 'https://protonchain.com/wallet',
    anchor: 'https://greymass.com/en/anchor/',
}

const defaultSupportedChains = {
    aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906: 'https://eos.greymass.com',
    '2a02a0053e5a8cf73a56ba0fda11e4d92e0238a4a2aa74fccf46d5a910746840':
        'https://jungle3.greymass.com',
    '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11':
        'https://telos.greymass.com',
    '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4': 'https://wax.greymass.com',
    '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0':
        'https://proton.greymass.com',
}

interface DialogArgs {
    title: string | HTMLElement
    manual?: HTMLElement
    subtitle?: string | HTMLElement
    type?: string
    content?: Record<string, any>
    action?: { text: string; callback: () => void }
    footnote?: string | HTMLElement,
    hideLogo?: boolean,
    hideBackButton?: boolean
}

class Storage implements LinkStorage {
    constructor(readonly keyPrefix: string) { }
    async write(key: string, data: string): Promise<void> {
        localStorage.setItem(this.storageKey(key), data)
    }
    async read(key: string): Promise<string | null> {
        return localStorage.getItem(this.storageKey(key))
    }
    async remove(key: string): Promise<void> {
        localStorage.removeItem(this.storageKey(key))
    }
    storageKey(key: string) {
        return `${this.keyPrefix}-${key}`
    }
}

export default class BrowserTransport implements LinkTransport {
    /** Package version. */
    static version = '__ver' // replaced by build script

    storage: LinkStorage

    constructor(public readonly options: BrowserTransportOptions = {}) {
        this.classPrefix = options.classPrefix || 'proton-link'
        this.requestStatus = !(options.requestStatus === false)
        this.requestAccount = options.requestAccount || ''
        this.walletType = options.walletType || 'proton'
        this.backButton = !(options.backButton === false)
        this.fuelEnabled = options.disableGreymassFuel !== true
        this.fuelReferrer = options.fuelReferrer || 'teamgreymass'
        this.storage = new Storage(options.storagePrefix || 'proton-link')
        this.supportedChains = options.supportedChains || defaultSupportedChains
        this.showingManual = false
    }

    private classPrefix: string
    private requestStatus: boolean
    private requestAccount: string
    private walletType: string
    private backButton: boolean
    private fuelEnabled: boolean
    private fuelReferrer: string
    private supportedChains: Record<string, string>
    private activeRequest?: SigningRequest
    private activeCancel?: (reason: string | Error) => void
    private countdownTimer?: NodeJS.Timeout
    private closeTimer?: NodeJS.Timeout
    private prepareStatusEl?: HTMLElement
    private showingManual: boolean

    private Widget?: DialogWidget

    private fontAdded: boolean = false;

    private closeModal() {
        this.hide()
        if (this.activeCancel) {
            this.activeRequest = undefined
            this.activeCancel('Modal closed')
            this.activeCancel = undefined
        }
    }

    private setupWidget() {
        this.showingManual = false

        if (!this.fontAdded) {
            const font = document.createElement('link')
            font.href = 'https://fonts.cdnfonts.com/css/circular-std-book'
            font.rel = 'stylesheet'
            document.head.appendChild(font);
            this.fontAdded = true;
        }

        if (!this.Widget) {
            const widgetHolder = document.createElement('div')
            document.body.appendChild(widgetHolder);
            this.Widget = new DialogWidget({
                target: widgetHolder
            })

            this.Widget.$on('back', () => {
                document.dispatchEvent(new CustomEvent('backToSelector'))
            })

            this.Widget.$on('close', () => {
                this.closeModal()
            })
        }
    }

    private createEl(attrs?: { [key: string]: any }): HTMLElement {
        if (!attrs) attrs = {}
        const el = document.createElement(attrs.tag || 'div')
        for (const attr of Object.keys(attrs)) {
            const value = attrs[attr]
            switch (attr) {
                case 'src':
                    el.setAttribute(attr, value)
                    break
                case 'tag':
                    break
                case 'content':
                    if (typeof value === 'string') {
                        el.appendChild(document.createTextNode(value))
                    } else {
                        el.appendChild(value)
                    }
                    break
                case 'text':
                    el.appendChild(document.createTextNode(value))
                    break
                case 'class':
                    el.className = `${this.classPrefix}-${value}`
                    break
                default:
                    el.setAttribute(attr, value)
            }
        }
        return el
    }

    private hide() {
        this.Widget?.$set({
            show: false,
            title: '',
            subtitle: null,
            footnote: null,
            expiresIn: null,
            countDown: null,
            qrData: null,
            action: null,
        })
        this.clearTimers()
    }

    private show() {
        this.Widget?.$set({ show: true })
    }

    private showDialog(args: DialogArgs) {
        this.setupWidget()

        const props: Record<string, any> = {
            showBackButton: !args.hideBackButton,
            walletType: this.walletType
        };

        if (args.title) {
            props['title'] = args.title
        } else {
            props['title'] = ''
        }

        if (args.subtitle) {
            props['subtitle'] = args.subtitle
        } else {
            props['subtitle'] = ''
        }

        if (args.action) {
            props['action'] = args.action
        } else {
            props['action'] = null
        }

        if (args.footnote) {
            props['footnote'] = (args.footnote instanceof HTMLElement) ? args.footnote.outerHTML : args.footnote
        } else {
            props['footnote'] = null
        }

        this.Widget?.$set({ ...props, ...(args.content || {}) })
        this.show()
    }

    private async displayRequest(
        request: SigningRequest,
        title: string,
        subtitle: string
    ) {
        const sameDeviceRequest = request.clone()
        const returnUrl = generateReturnUrl()
        sameDeviceRequest.setInfoKey('same_device', true)
        sameDeviceRequest.setInfoKey('return_path', returnUrl)

        if (this.requestAccount.length > 0) {
            request.setInfoKey('req_account', this.requestAccount)
            sameDeviceRequest.setInfoKey('req_account', this.requestAccount)
        }

        const sameDeviceUri = sameDeviceRequest.encode(true, false)
        const crossDeviceUri = request.encode(true, false)

        const qrCode = await QRCode.toDataURL(crossDeviceUri)

        const qrData = {
            code: qrCode,
            link: sameDeviceUri
        }

        let footnote: HTMLElement = this.createEl({ class: 'footnote' })
        const isIdentity = request.isIdentity()
        if (isIdentity) {
            footnote = this.createEl({
                class: 'footnote',
                text: `Don't have a wallet? `,
            })
            const footnoteLink = this.createEl({
                tag: 'a',
                target: '_blank',
                href: footnoteLinks[this.walletType],
                text: 'Download it here',
            })
            footnote.appendChild(footnoteLink)
        }

        this.showDialog({
            title,
            footnote: footnote.innerHTML,
            subtitle,
            content: { qrData },
        })
    }

    public async showLoading() {
        this.showDialog({
            title: 'Pending...',
            subtitle: 'Preparing request...',
            type: 'loading',
        })
    }

    public onRequest(request: SigningRequest, cancel: (reason: string | Error) => void) {
        this.clearTimers()
        this.activeRequest = request
        this.activeCancel = cancel
        this.displayRequest(
            request,
            'Scan the QR-Code',
            '',
        ).catch(cancel)
    }

    public onSessionRequest(
        session: LinkSession,
        request: SigningRequest,
        cancel: (reason: string | Error) => void
    ) {
        if (session.metadata.sameDevice) {
            request.setInfoKey('return_path', generateReturnUrl())
        }

        if (session.type === 'fallback') {
            this.onRequest(request, cancel)
            if (session.metadata.sameDevice) {
                // trigger directly on a fallback same-device session
                window.location.href = request.encode()
            }
            return
        }

        this.clearTimers()
        this.activeRequest = request
        this.activeCancel = cancel

        const timeout = session.metadata.timeout || 60 * 1000 * 2
        const deviceName = session.metadata.name

        // Content timer
        const start = Date.now()

        const formatCountDown = (startTime: number) => {
            const timeLeft = timeout + startTime - Date.now()
            return timeLeft > 0 ? new Date(timeLeft).toISOString().substring(14, 5) : '00:00'
        }

        const updateCountdown = (startTime: number) => {
            this.Widget?.$set({ countDown: formatCountDown(startTime) })
        }

        this.countdownTimer = setInterval(() => {
            updateCountdown(start)
        }, 500)
        updateCountdown(start)

        // Content subtitle
        let subtitle: string
        if (deviceName && deviceName.length > 0) {
            subtitle = `Please open ${deviceName} to review the transaction`
        } else {
            subtitle = 'Please review and sign the transaction in the linked wallet.'
        }

        this.showDialog({
            title: 'Signing Request',
            subtitle,
            content: {
                countDown: formatCountDown(start)
            },
            hideBackButton: true,
            action: {
                text: 'Optional: Sign manually using QR code',
                callback: () => {
                    const error = new SessionError('Manual', 'E_TIMEOUT', session)
                    error[SkipToManual] = true
                    cancel(error)
                },
            },
        })

        if (session.metadata.sameDevice) {
            if (isMobile()) {
                const scheme = request.getScheme()
                window.location.href = `${scheme}://link`
            }
        }
    }

    public sendSessionPayload(payload: Bytes, session: LinkSession): boolean {
        if (!session.metadata.triggerUrl || !session.metadata.sameDevice) {
            // not same device or no trigger url supported
            return false
        }
        if (payload.array.length > 700) {
            // url could be clipped by iOS
            return false
        }
        window.location.href = session.metadata.triggerUrl.replace(
            '%s',
            Base64u.encode(payload.array)
        )
        return true
    }

    private clearTimers() {
        if (this.closeTimer) {
            clearTimeout(this.closeTimer)
            this.closeTimer = undefined
        }
        if (this.countdownTimer) {
            clearTimeout(this.countdownTimer)
            this.countdownTimer = undefined
        }
    }

    private async showFee(request: SigningRequest, fee: string) {
        this.activeRequest = request
        const cancelPromise = new Promise((resolve, reject) => {
            this.activeCancel = (reason) => {
                let error: Error
                if (typeof reason === 'string') {
                    error = new Error(reason)
                } else {
                    error = reason
                }
                error[AbortPrepare] = true
                reject(error)
            }
        })

        const expires = request.getRawTransaction().expiration.toDate()
        const expireTimer = setInterval(() => {
            this.Widget?.$set({ expiresIn: countdownFormat(expires) })

            if (expires.getTime() < Date.now()) {
                this.activeCancel!('Offer expired')
            }
        }, 200)

        const skipPromise = new Promise((resolve) => {
            const off = this.Widget?.$on('no-fee', (event) => {
                resolve(event)
                off!();
            })
        }).then(() => {
            const error = new Error('Skipped fee')
            error[SkipFee] = true
            throw error
        })

        const footnote = this.createEl({
            tag: 'span',
            text: 'Resources offered by ',
        })
        const footnoteLink = this.createEl({
            tag: 'a',
            target: '_blank',
            href: 'https://greymass.com/en/fuel',
            text: 'Greymass Fuel',
        })
        footnote.appendChild(footnoteLink)

        const confirmPromise = new Promise<void>((resolve) => {
            this.showDialog({
                title: 'Transaction Fee',
                subtitle:
                    'Your account lacks the network resources for this transaction and it cannot be covered for free.',
                type: 'fuel',
                content: {
                    expiresIn: countdownFormat(expires)
                },
                action: {
                    text: `Accept Fee of ${fee}`,
                    callback: resolve,
                },
                footnote: footnote.outerHTML,
            })
        })

        await Promise.race([confirmPromise, skipPromise, cancelPromise]).finally(() => {
            clearInterval(expireTimer)
        })
    }

    private showRecovery(request: SigningRequest, session: LinkSession) {
        request.data.info = request.data.info.filter((pair) => pair.key !== 'return_path')
        if (session.type === 'channel') {
            const channelSession = session as Partial<LinkChannelSession>
            if (channelSession.addLinkInfo) {
                channelSession.addLinkInfo(request)
            }
        }
        this.displayRequest(
            request,
            'Sign manually',
            ''
        )
        this.showingManual = true
    }

    public async prepare(request: SigningRequest, session?: LinkSession) {
        this.showLoading()
        if (!this.fuelEnabled || !session || request.isIdentity() || this.walletType === 'proton') {
            // don't attempt to cosign id request or if we don't have a session attached
            return request
        }
        if (
            typeof session.metadata.cosignerVersion === 'string' &&
            fuelVersion(session.metadata.cosignerVersion)
        ) {
            // if signer has cosigner, only attempt to cosign here if we have a newer version
            return request
        }
        try {
            const result = fuel(
                request,
                session,
                (message: string) => {
                    if (this.prepareStatusEl) {
                        this.prepareStatusEl.textContent = message
                    }
                },
                this.supportedChains,
                this.fuelReferrer
            )
            const timeout = new Promise((r) => setTimeout(r, 5000)).then(() => {
                throw new Error('API timeout after 5000ms')
            })
            const modified = await Promise.race([result, timeout])
            const fee = modified.getInfoKey('txfee')
            if (fee) {
                await this.showFee(modified, String(fee))
            }
            return modified
        } catch (error) {
            if ((error as any)[AbortPrepare]) {
                this.hide()
                throw error
            } else {
                // eslint-disable-next-line no-console
                console.info(`Skipping resource provider: ${(error as any).message || error}`)
                if ((error as any)[SkipFee]) {
                    const modified = request.clone()
                    modified.setInfoKey('no_fee', true, 'bool')
                    return modified
                }
            }
        }
        return request
    }

    public recoverError(error: Error, request: SigningRequest) {
        if (
            request === this.activeRequest &&
            (error['code'] === 'E_DELIVERY' || error['code'] === 'E_TIMEOUT') &&
            error['session']
        ) {
            // recover from session errors by displaying a manual sign dialog
            if (this.showingManual) {
                // already showing recovery sign
                return true
            }
            const session: LinkSession = error['session']
            if (error[SkipToManual]) {
                this.showRecovery(request, session)
                return true
            }
            const deviceName = session.metadata.name
            let subtitle: string
            if (deviceName && deviceName.length > 0) {
                subtitle = `Unable to deliver the request to ${deviceName}.`
            } else {
                subtitle = 'Unable to deliver the request to the linked wallet.'
            }
            subtitle += ` ${error.message}.`
            this.showDialog({
                title: 'Unable to reach device',
                subtitle,
                type: 'warning',
                action: {
                    text: 'Optional: Sign manually using QR code',
                    callback: () => {
                        this.showRecovery(request, session)
                    },
                },
            })
            return true
        }
        return false
    }

    public onSuccess(request: SigningRequest) {
        if (request === this.activeRequest) {
            this.clearTimers()
            if (this.requestStatus) {
                this.showDialog({
                    title: 'Success!',
                    subtitle: request.isIdentity() ? 'Login completed.' : 'Transaction signed.',
                    type: 'success',
                })
                this.closeTimer = setTimeout(() => {
                    this.hide()
                }, 1.5 * 1000)
            } else {
                this.hide()
            }
        }
    }

    public onFailure(request: SigningRequest, error: Error) {
        if (request === this.activeRequest && (error as any)['code'] !== 'E_CANCEL') {
            this.clearTimers()
            if (this.requestStatus) {
                let errorMessage: string
                if (isInstanceOf(error, APIError)) {
                    if (error.name === 'eosio_assert_message_exception') {
                        errorMessage = error.details[0].message
                    } else if (error.details.length > 0) {
                        errorMessage = error.details.map((d) => d.message).join('\n')
                    } else {
                        errorMessage = error.message
                    }
                } else {
                    errorMessage = (error as any).message || String(error)
                }
                this.showDialog({
                    title: 'Transaction Error',
                    subtitle: errorMessage,
                    type: 'error',
                })
            } else {
                this.hide()
            }
        } else {
            this.hide()
        }
    }

    public userAgent() {
        return `BrowserTransport/${BrowserTransport.version} ${navigator.userAgent}`
    }
}

function countdownFormat(date: Date) {
    const timeLeft = date.getTime() - Date.now()
    if (timeLeft > 0) {
        return new Date(timeLeft).toISOString().substring(14, 5)
    }
    return '00:00'
}

/** Generate a return url that Proton will redirect back to w/o reload. */
function generateReturnUrl() {
    if (isChromeiOS()) {
        // google chrome on iOS will always open new tab so we just ask it to open again as a workaround
        return 'googlechrome://'
    }
    if (isFirefoxiOS()) {
        // same for firefox
        return 'firefox:://'
    }
    if (isAppleHandheld() && isBrave()) {
        // and brave ios
        return 'brave://'
    }
    if (isAppleHandheld()) {
        // return url with unique fragment required for iOS safari to trigger the return url
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
        let rv = window.location.href.split('#')[0] + '#'
        for (let i = 0; i < 8; i++) {
            rv += alphabet.charAt(Math.floor(Math.random() * alphabet.length))
        }
        return rv
    }

    if (isAndroid() && isFirefox()) {
        return 'android-intent://org.mozilla.firefox'
    }

    if (isAndroid() && isEdge()) {
        return 'android-intent://com.microsoft.emmx'
    }

    if (isAndroid() && isOpera()) {
        return 'android-intent://com.opera.browser'
    }

    if (isAndroid() && isBrave()) {
        return 'android-intent://com.brave.browser'
    }

    if (isAndroid() && isAndroidWebView()) {
        return 'android-intent://webview'
    }

    if (isAndroid() && isChromeMobile()) {
        return 'android-intent://com.android.chrome'
    }

    return window.location.href
}

